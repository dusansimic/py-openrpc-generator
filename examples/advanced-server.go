// Advanced Example API
// A comprehensive API spec demonstrating all OpenRPC features
// Version: 2.0.0
//
// Auto-generated by py-openrpc-generator
// Target: github.com/gorilla/rpc/v2 (JSON-RPC 2.0)
// DO NOT EDIT — regenerate from the OpenRPC specification.

package main

import (
	"fmt"
	"log"
	"net/http"

	"github.com/gorilla/rpc/v2"
	"github.com/gorilla/rpc/v2/json2"
)

// ============================================================================
// Type Definitions (from components/schemas)
// ============================================================================

type User struct {
	ID string `json:"id"`
	Name string `json:"name"`
	Email string `json:"email"`
	Age *int64 `json:"age,omitempty"`
	Status string `json:"status"`
	CreatedAt string `json:"createdAt"`
}

type UserServiceUpdateArgsData struct {
	Name *string `json:"name,omitempty"`
	Email *string `json:"email,omitempty"`
}

type MathServiceAddResult struct {
	Result float64 `json:"result"`
}

type SearchServiceQueryArgsFilters struct {
	EntityType *string `json:"entityType,omitempty"`
	DateFrom *string `json:"dateFrom,omitempty"`
	DateTo *string `json:"dateTo,omitempty"`
}

type SearchServiceQueryResultItem struct {
	ID string `json:"id"`
	Type string `json:"type"`
	Title string `json:"title"`
	Score float64 `json:"score"`
}

type SearchServiceQueryResult struct {
	Items []SearchServiceQueryResultItem `json:"items"`
	Total int64 `json:"total"`
}

// ============================================================================
// Error Types
// ============================================================================

// JSONRPCError is the base type for typed JSON-RPC errors returned by handlers.
// Return one of these (or a sub-type) from your handler methods to send a
// structured error code back to the client.
type JSONRPCError struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data,omitempty"`
}

func (e *JSONRPCError) Error() string {
	return fmt.Sprintf("JSON-RPC error %d: %s", e.Code, e.Message)
}

// UserNotFoundError represents error code 1001: User not found
type UserNotFoundError struct {
	JSONRPCError
}

// NewUserNotFoundError constructs a UserNotFoundError with optional data.
func NewUserNotFoundError(data interface{}) *UserNotFoundError {
	return &UserNotFoundError{
		JSONRPCError: JSONRPCError{
			Code:    1001,
			Message: "User not found",
			Data:    data,
		},
	}
}

// InvalidUserIdFormatError represents error code 1004: Invalid user ID format
type InvalidUserIdFormatError struct {
	JSONRPCError
}

// NewInvalidUserIdFormatError constructs a InvalidUserIdFormatError with optional data.
func NewInvalidUserIdFormatError(data interface{}) *InvalidUserIdFormatError {
	return &InvalidUserIdFormatError{
		JSONRPCError: JSONRPCError{
			Code:    1004,
			Message: "Invalid user ID format",
			Data:    data,
		},
	}
}

// EmailAlreadyExistsError represents error code 1002: Email already exists
type EmailAlreadyExistsError struct {
	JSONRPCError
}

// NewEmailAlreadyExistsError constructs a EmailAlreadyExistsError with optional data.
func NewEmailAlreadyExistsError(data interface{}) *EmailAlreadyExistsError {
	return &EmailAlreadyExistsError{
		JSONRPCError: JSONRPCError{
			Code:    1002,
			Message: "Email already exists",
			Data:    data,
		},
	}
}

// InvalidEmailFormatError represents error code 1003: Invalid email format
type InvalidEmailFormatError struct {
	JSONRPCError
}

// NewInvalidEmailFormatError constructs a InvalidEmailFormatError with optional data.
func NewInvalidEmailFormatError(data interface{}) *InvalidEmailFormatError {
	return &InvalidEmailFormatError{
		JSONRPCError: JSONRPCError{
			Code:    1003,
			Message: "Invalid email format",
			Data:    data,
		},
	}
}

// ============================================================================
// MathService — handles "math.*" RPC methods
//
// JSON-RPC method names are mapped as follows:
//   "<namespace>.<GoMethodName>" e.g. "math.MethodName"
// The json2 codec performs case-insensitive method name matching, so
// e.g. "math.getById" will match "math.GetById".
// ============================================================================

// MathServiceAddArgs contains the arguments for math.add.
// NOTE: This method uses positional parameters (paramStructure: by-position).
// Gorilla RPC expects a JSON object; if positional array encoding is required
// implement a custom json.Unmarshaler on this struct.
type MathServiceAddArgs struct {
	// First number
	A float64 `json:"a"`
	// Second number
	B float64 `json:"b"`
}

// MathServiceAddReply contains the result for math.add.
type MathServiceAddReply = MathServiceAddResult

// MathService implements the "math" RPC service.
// Register it with: server.RegisterService(new(MathService), "math")
type MathService struct{}

// Add handles math.add.
// Add two numbers
//
// Returns the sum of two numbers using positional parameters
func (s *MathService) Add(r *http.Request, args *MathServiceAddArgs, reply *MathServiceAddReply) error {
	// TODO: implement math.add
	return nil
}

// ============================================================================
// NotificationsService — handles "notifications.*" RPC methods
//
// JSON-RPC method names are mapped as follows:
//   "<namespace>.<GoMethodName>" e.g. "notifications.MethodName"
// The json2 codec performs case-insensitive method name matching, so
// e.g. "notifications.getById" will match "notifications.GetById".
// ============================================================================

// NotificationsServiceSubscribeArgs contains the arguments for notifications.subscribe.
type NotificationsServiceSubscribeArgs struct {
	// Notification channel
	Channel string `json:"channel"`
}

// NotificationsServiceSubscribeReply contains the result for notifications.subscribe.
type NotificationsServiceSubscribeReply struct{}

// NotificationsService implements the "notifications" RPC service.
// Register it with: server.RegisterService(new(NotificationsService), "notifications")
type NotificationsService struct{}

// Subscribe handles notifications.subscribe.
// Subscribe to notifications
//
// Subscribe to real-time notifications (notification method, no response expected)
func (s *NotificationsService) Subscribe(r *http.Request, args *NotificationsServiceSubscribeArgs, reply *NotificationsServiceSubscribeReply) error {
	// TODO: implement notifications.subscribe
	return nil
}

// ============================================================================
// SearchService — handles "search.*" RPC methods
//
// JSON-RPC method names are mapped as follows:
//   "<namespace>.<GoMethodName>" e.g. "search.MethodName"
// The json2 codec performs case-insensitive method name matching, so
// e.g. "search.getById" will match "search.GetById".
// ============================================================================

// SearchServiceQueryArgs contains the arguments for search.query.
type SearchServiceQueryArgs struct {
	// Search query string
	Query string `json:"query"`
	// Search filters
	Filters *SearchServiceQueryArgsFilters `json:"filters,omitempty"`
}

// SearchServiceQueryReply contains the result for search.query.
type SearchServiceQueryReply = SearchServiceQueryResult

// SearchService implements the "search" RPC service.
// Register it with: server.RegisterService(new(SearchService), "search")
type SearchService struct{}

// Query handles search.query.
// Search across entities
//
// Performs a full-text search across multiple entity types
func (s *SearchService) Query(r *http.Request, args *SearchServiceQueryArgs, reply *SearchServiceQueryReply) error {
	// TODO: implement search.query
	return nil
}

// ============================================================================
// UserService — handles "user.*" RPC methods
//
// JSON-RPC method names are mapped as follows:
//   "<namespace>.<GoMethodName>" e.g. "user.MethodName"
// The json2 codec performs case-insensitive method name matching, so
// e.g. "user.getById" will match "user.GetById".
// ============================================================================

// UserServiceGetByIdArgs contains the arguments for user.getById.
type UserServiceGetByIdArgs struct {
	// The unique identifier of the user
	UserID string `json:"userId"`
}

// UserServiceGetByIdReply contains the result for user.getById.
type UserServiceGetByIdReply = User

// UserServiceCreateArgs contains the arguments for user.create.
type UserServiceCreateArgs struct {
	// User's full name
	Name string `json:"name"`
	// User's email address
	Email string `json:"email"`
	// User's age
	Age *int64 `json:"age,omitempty"`
}

// UserServiceCreateReply contains the result for user.create.
type UserServiceCreateReply = User

// UserServiceUpdateArgs contains the arguments for user.update.
type UserServiceUpdateArgs struct {
	// The unique identifier of the user
	UserID string `json:"userId"`
	// User data to update
	Data UserServiceUpdateArgsData `json:"data"`
}

// UserServiceUpdateReply contains the result for user.update.
type UserServiceUpdateReply = User

// UserService implements the "user" RPC service.
// Register it with: server.RegisterService(new(UserService), "user")
type UserService struct{}

// GetById handles user.getById.
// Get user by ID
//
// Retrieves a user object by their unique identifier
// Errors:
//   1001: User not found
//   1004: Invalid user ID format
func (s *UserService) GetById(r *http.Request, args *UserServiceGetByIdArgs, reply *UserServiceGetByIdReply) error {
	// TODO: implement user.getById
	return nil
}

// Create handles user.create.
// Create a new user
//
// Creates a new user with the provided information
// Errors:
//   1002: Email already exists
//   1003: Invalid email format
func (s *UserService) Create(r *http.Request, args *UserServiceCreateArgs, reply *UserServiceCreateReply) error {
	// TODO: implement user.create
	return nil
}

// Deprecated: Update user (DEPRECATED). Updates an existing user. Use user.patch instead.
// Update handles user.update.
// Update user (DEPRECATED)
//
// Updates an existing user. Use user.patch instead.
func (s *UserService) Update(r *http.Request, args *UserServiceUpdateArgs, reply *UserServiceUpdateReply) error {
	// TODO: implement user.update
	return nil
}

// ============================================================================
// Server Setup
// ============================================================================

func main() {
	server := rpc.NewServer()
	server.RegisterCodec(json2.NewCodec(), "application/json")

	if err := server.RegisterService(new(MathService), "math"); err != nil {
		log.Fatalf("failed to register MathService: %v", err)
	}
	if err := server.RegisterService(new(NotificationsService), "notifications"); err != nil {
		log.Fatalf("failed to register NotificationsService: %v", err)
	}
	if err := server.RegisterService(new(SearchService), "search"); err != nil {
		log.Fatalf("failed to register SearchService: %v", err)
	}
	if err := server.RegisterService(new(UserService), "user"); err != nil {
		log.Fatalf("failed to register UserService: %v", err)
	}

	http.Handle("/rpc", server)

	port := "443"
	log.Printf("JSON-RPC 2.0 server listening on :%s", port)
	log.Fatal(http.ListenAndServe(":"+port, nil))
}