// {{ info.title }}
// {{ info.description }}
// Version: {{ info.version }}
//
// Auto-generated by py-openrpc-generator
// Target: github.com/gorilla/rpc/v2 (JSON-RPC 2.0)
// DO NOT EDIT — regenerate from the OpenRPC specification.

package {{ package_name }}

import (
{% if error_types %}
	"fmt"
{% endif %}
	"net/http"
)

{% if type_definitions %}
// ============================================================================
// Type Definitions (from components/schemas)
// ============================================================================

{{ type_definitions }}

{% endif %}
{% if error_types %}
// ============================================================================
// Error Types
// ============================================================================

// JSONRPCError is the base type for typed JSON-RPC errors returned by handlers.
// Return one of these (or a sub-type) from your handler methods to send a
// structured error code back to the client.
type JSONRPCError struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data,omitempty"`
}

func (e *JSONRPCError) Error() string {
	return fmt.Sprintf("JSON-RPC error %d: %s", e.Code, e.Message)
}

{% for err in error_types %}
// {{ err.struct_name }} represents error code {{ err.code }}: {{ err.message }}
type {{ err.struct_name }} struct {
	JSONRPCError
}

// New{{ err.struct_name }} constructs a {{ err.struct_name }} with optional data.
func New{{ err.struct_name }}(data interface{}) *{{ err.struct_name }} {
	return &{{ err.struct_name }}{
		JSONRPCError: JSONRPCError{
			Code:    {{ err.code }},
			Message: "{{ err.message }}",
			Data:    data,
		},
	}
}

{% endfor %}
{% endif %}
{% for service in services %}
// ============================================================================
// {{ service.name }} — handles "{{ service.namespace }}.*" RPC methods
//
// JSON-RPC method names are mapped as follows:
//   "<namespace>.<GoMethodName>" e.g. "{{ service.namespace }}.MethodName"
// The json2 codec performs case-insensitive method name matching, so
// e.g. "{{ service.namespace }}.getById" will match "{{ service.namespace }}.GetById".
// ============================================================================

{% for method in service.methods %}
// {{ method.args_type }} contains the arguments for {{ method.name }}.
{% if method.is_positional %}
// NOTE: This method uses positional parameters (paramStructure: by-position).
// Gorilla RPC expects a JSON object; if positional array encoding is required
// implement a custom json.Unmarshaler on this struct.
{% endif %}
{% if method.has_args %}
type {{ method.args_type }} struct {
{% for field in method.args_fields %}
{% if field.description %}
	// {{ field.description }}
{% endif %}
	{{ field.go_name }} {{ field.go_type }} {{ field.tag }}
{% endfor %}
}
{% else %}
type {{ method.args_type }} struct{}
{% endif %}

// {{ method.reply_type }} contains the result for {{ method.name }}.
{% if method.is_notification %}
type {{ method.reply_type }} struct{}
{% elif method.reply_is_alias and method.reply_inline_type %}
type {{ method.reply_type }} = {{ method.reply_inline_type }}
{% else %}
type {{ method.reply_type }} struct{}
{% endif %}

{% endfor %}
// {{ service.name }}Handler is the interface your implementation must satisfy.
// Register your concrete type with:
//
//	server.RegisterService(yourImpl, "{{ service.namespace if service.namespace != "default" else "" }}")
type {{ service.name }}Handler interface {
{% for method in service.methods %}
	// {{ method.go_method_name }} handles "{{ method.name }}".
{% if method.summary %}
	// {{ method.summary }}
{% endif %}
{% if method.deprecated %}
	// Deprecated: {{ method.summary or method.go_method_name }}.
{% endif %}
	{{ method.go_method_name }}(r *http.Request, args *{{ method.args_type }}, reply *{{ method.reply_type }}) error
{% endfor %}
}

{% endfor %}
